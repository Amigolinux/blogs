<!doctype html>
<html class="no-js" lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />

		<title>kamidox.com</title>
		<meta name="description" content="">
		<meta name="author" content="Joey Huang">

		<link rel="stylesheet" href="../theme/css/foundation.css" />
		<link rel="stylesheet" href="../theme/css/pygment/monokai.css" />
		<link rel="stylesheet" href="../theme/css/custom.css" />


		<link rel="shortcut icon" href="../theme/img/favicon.ico">

		<script src="../theme/js/modernizr.js"></script>

		<!-- Feeds -->


		<!-- mathjax config similar to math.stackexchange -->
		<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
		<script>
		MathJax.Hub.Config({
		  config: ["MMLorHTML.js"],
		  extensions: ["tex2jax.js"],
		  jax: ["input/TeX"],
		  tex2jax: {
		    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
		    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
		    processEscapes: false
		  },
		  TeX: {
		    extensions: ["AMSmath.js", "AMSsymbols.js"],
		    TagSide: "right",
		    TagIndent: ".8em",
		    MultLineWidth: "85%",
		    equationNumbers: {
		      autoNumber: "AMS",
		    },
		    unicode: {
		      fonts: "STIXGeneral,'Arial Unicode MS'"
		    }
		  },
		  showProcessingMessages: false
		});
		</script>
	</head>
	<body>
		<div class="off-canvas-wrap">
			<div class="inner-wrap">
				<!-- mobile top bar to activate nav -->
				<nav class="tab-bar show-for-small">
					<section class="left-small">
						<a class="left-off-canvas-toggle menu-icon" ><span></span></a>
					</section>

					<section class="middle tab-bar-section">
						<h1 class="title">kamidox.com</h1>
					</section>
				</nav>

				<!-- mobile side bar nav -->
				<aside class="left-off-canvas-menu">
					<ul class="off-canvas-list">
							<li><a href="http://blog.kamidox.com">Home</a></li>
							<li><a href="http://blog.kamidox.com/about.html">About</a></li>

						<li><label>Categories</label></li>
							<li ><a href="../category/android.html">android</a></li>
							<li ><a href="../category/essay.html">essay</a></li>
							<li ><a href="../category/flask.html">flask</a></li>
							<li ><a href="../category/ml.html">ml</a></li>
							<li ><a href="../category/nlp.html">nlp</a></li>
							<li ><a href="../category/python.html">python</a></li>
							<li ><a href="../category/tools.html">tools</a></li>
							<li ><a href="../category/werkzeug.html">werkzeug</a></li>




						<li><label>Monthly Archives</label></li>
									<li><a href="/posts/2016/03/index.html">March 2016 (2)</a></li>
									<li><a href="/posts/2016/02/index.html">February 2016 (2)</a></li>
									<li><a href="/posts/2016/01/index.html">January 2016 (2)</a></li>
									<li><a href="/posts/2015/12/index.html">December 2015 (10)</a></li>
									<li><a href="/posts/2015/11/index.html">November 2015 (6)</a></li>
									<li><a href="/posts/2015/10/index.html">October 2015 (2)</a></li>
									<li><a href="/posts/2015/09/index.html">September 2015 (7)</a></li>
									<li><a href="/posts/2015/08/index.html">August 2015 (1)</a></li>
									<li><a href="/posts/2015/07/index.html">July 2015 (1)</a></li>
									<li><a href="/posts/2015/05/index.html">May 2015 (1)</a></li>
									<li><a href="/posts/2015/04/index.html">April 2015 (1)</a></li>
									<li><a href="/posts/2015/03/index.html">March 2015 (3)</a></li>
									<li><a href="/posts/2015/02/index.html">February 2015 (2)</a></li>
									<li><a href="/posts/2015/01/index.html">January 2015 (2)</a></li>
									<li><a href="/posts/2014/12/index.html">December 2014 (3)</a></li>
									<li><a href="/posts/2014/11/index.html">November 2014 (4)</a></li>
									<li><a href="/posts/2014/10/index.html">October 2014 (6)</a></li>
									<li><a href="/posts/2014/09/index.html">September 2014 (1)</a></li>
									<li><a href="/posts/2014/07/index.html">July 2014 (1)</a></li>


					</ul>
				</aside>

				<!-- top bar nav -->
				<nav class="top-bar hide-for-small-only" data-topbar>
					<ul class="title-area">
						<li class="name">
							<h1><a href="../">kamidox.com</a></h1>
						</li>
					</ul>

					<section class="top-bar-section">
						<ul class="left">
								<li><a href="http://blog.kamidox.com">Home</a></li>
								<li><a href="http://blog.kamidox.com/about.html">About</a></li>

						</ul>
					</section>
				</nav>

				<!-- Main Page Content and Sidebar -->
				<section class="main-section">
					<div class="row">
						<!-- Main Content -->
						<div class="medium-9 small-12 columns" role="content">
<article>
	<h2>日积月累</h2>
	<div class="toc">
<ul>
<li><a href="#20160406">20160406</a><ul>
<li><a href="#pelican">Pelican 代码阅读</a></li>
</ul>
</li>
<li><a href="#20150413">20150413</a><ul>
<li><a href="#alfred-stackoverflow-github">配置 Alfred 来搜索 StackOverflow 和 Github</a></li>
<li><a href="#unsplash-api">unsplash api</a></li>
<li><a href="#unsplash">壁纸应用，图片来自 unsplash</a></li>
</ul>
</li>
<li><a href="#20150416">20150416</a><ul>
<li><a href="#wallsplash-android-mainactivityjava">wallsplash-android MainActivity.java</a></li>
<li><a href="#wallsplash-android-imagesfragmentjava">wallsplash-android ImagesFragment.java</a></li>
<li><a href="#wallsplash-android-unsplashapijava">wallsplash-android UnsplashApi.java</a></li>
</ul>
</li>
<li><a href="#20150423">20150423</a><ul>
<li><a href="#_1">做成一件事情</a></li>
</ul>
</li>
<li><a href="#20150419">20150419</a><ul>
<li><a href="#android-performance-training">Android Performance Training</a></li>
</ul>
</li>
<li><a href="#20150607">20150607</a><ul>
<li><a href="#_2">《持续的幸福》阅读笔记</a></li>
</ul>
</li>
<li><a href="#20160614">20160614</a><ul>
<li><a href="#the-nodejs-philosophy">The Node.js philosophy</a></li>
</ul>
</li>
<li><a href="#20160615">20160615</a><ul>
<li><a href="#the-reactor-pattern">The reactor pattern</a></li>
</ul>
</li>
<li><a href="#20160616">20160616</a><ul>
<li><a href="#the-callback-pattern">The callback pattern</a></li>
</ul>
</li>
<li><a href="#20160620">20160620</a><ul>
<li><a href="#the-module-system-and-its-patterns">The module system and its patterns</a></li>
</ul>
</li>
<li><a href="#20160621">20160621</a><ul>
<li><a href="#rethinkdb">rethinkdb</a></li>
<li><a href="#leancloud">leancloud</a></li>
<li><a href="#wilddog">wilddog</a></li>
<li><a href="#iot">带网关的 IoT 系统通信需求</a></li>
<li><a href="#websocket-long-polling">websocket &amp; long-polling</a></li>
<li><a href="#xaas">XaaS</a></li>
</ul>
</li>
<li><a href="#20160622">20160622</a><ul>
<li><a href="#the-observer-pattern">The observer pattern</a></li>
</ul>
</li>
<li><a href="#20160624">20160624</a><ul>
<li><a href="#the-difficulties-of-asynchronous-programming">The difficulties of asynchronous programming</a></li>
<li><a href="#using-plain-javascript">Using plain JavaScript</a></li>
</ul>
</li>
<li><a href="#20160627">20160627</a><ul>
<li><a href="#parallel-execution">Parallel execution</a></li>
</ul>
</li>
<li><a href="#20160630">20160630</a><ul>
<li><a href="#limiting-the-concurrency">Limiting the concurrency</a></li>
<li><a href="#globally-limiting-the-concurrency">Globally limiting the concurrency</a></li>
</ul>
</li>
<li><a href="#20160704">20160704</a><ul>
<li><a href="#the-async-library">The async library</a></li>
<li><a href="#promises">Promises</a><ul>
<li><a href="#what-is-a-promise">What is a promise?</a></li>
<li><a href="#promisesa-implementations">Promises/A+ implementations</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#20160705">20160705</a><ul>
<li><a href="#_3">选股辅助系统</a></li>
</ul>
</li>
<li><a href="#20160706">20160706</a><ul>
<li><a href="#promises_1">Promises</a><ul>
<li><a href="#promisifying-a-nodejs-style-function">Promisifying a Node.js style function</a></li>
<li><a href="#sequential-execution">Sequential execution</a></li>
<li><a href="#parallel-execution_1">Parallel execution</a></li>
<li><a href="#limited-parallel-execution">Limited parallel execution</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h2 id="20160406">20160406</h2>
<h3 id="pelican">Pelican 代码阅读</h3>
<ul>
<li>命令行参数解析: python std lib -&gt; argparse</li>
<li>Log 系统: python std lib -&gt; logging</li>
<li>导入 pelicanconf.py 中的设置信息<br />
  使用 <code>imp.load_source()</code> 或 <code>SourceFileLoader().load_module()</code> 把 <code>pelicanconf.py</code> 作为模块导入，再使用 <code>inspect.getmembers()</code> 来获取模块里的变量，所有的全大写的变量作为设置信息读取进来。导入模块时，也可以使用 <code>__import__()</code> 函数，但参数的形式是不一样的。</li>
<li>给定一个字符串 <code>pelican.Pelican</code>，怎么样用这个字符串所代表的类创建对象？<br />
  使用 <code>__import__</code> 和 <code>getattr()</code> 实现</li>
</ul>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%">    cls <span style="color: #666666">=</span> settings[<span style="color: #BB4444">&#39;PELICAN_CLASS&#39;</span>]     <span style="color: #008800; font-style: italic"># default class: &#39;pelican.Pelican&#39;</span>
    <span style="color: #AA22FF; font-weight: bold">if</span> <span style="color: #AA22FF">isinstance</span>(cls, six<span style="color: #666666">.</span>string_types):
        module, cls_name <span style="color: #666666">=</span> cls<span style="color: #666666">.</span>rsplit(<span style="color: #BB4444">&#39;.&#39;</span>, <span style="color: #666666">1</span>)
        module <span style="color: #666666">=</span> <span style="color: #AA22FF">__import__</span>(module)
        cls <span style="color: #666666">=</span> <span style="color: #AA22FF">getattr</span>(module, cls_name)

    <span style="color: #AA22FF; font-weight: bold">return</span> cls(settings), settings
</pre></div>


<ul>
<li>如何把某个目录加入当前的模块搜索目录？<br />
  把目录添加进 <code>sys.path</code> 列表即可</li>
<li>进程内信号/事件: 使用 <a href="https://github.com/jek/blinker">blinker</a> 实现</li>
<li>插件系统</li>
<li>使用进程内信号 <code>blinker</code> 来实现与插件的通信</li>
<li>插件需要实现 <code>register()</code> 函数，这个函数由 Pelican 在初始化时调用</li>
<li>插件需要注册 Pelican 系统的信号，根据不同的信号做相应的处理，具体参阅 <code>docs/plugins.rst</code> 以及 <code>pelican/signals.py</code>。</li>
<li>如何处理可选的依赖包？<br />
  比如 Pelican 支持多种文档格式 markdown, rst, etc. 怎么样确保只使用 markdown 的人没安装 rst 转码库 <code>docutils</code> 也能正常运行呢？这里的方法是处理 <code>ImportError</code>，并且当发生 <code>ImportError</code> 时禁用这个转换器。</li>
<li>TODO: Reader/Writer/Generator 源码阅读</li>
</ul>
<h2 id="20150413">20150413</h2>
<h4 id="alfred-stackoverflow-github">配置 Alfred 来搜索 StackOverflow 和 Github</h4>
<ul>
<li>StackOverflow<br />
  http://stackoverflow.com/search?q={query}</li>
<li>Github<br />
  https://github.com/search?q={query}</li>
</ul>
<h4 id="unsplash-api">unsplash api</h4>
<p>http://tumblr.unsplash.com/api/read?num=10</p>
<h4 id="unsplash">壁纸应用，图片来自 unsplash</h4>
<p>https://github.com/kamidox/wallsplash-android</p>
<h2 id="20150416">20150416</h2>
<h4 id="wallsplash-android-mainactivityjava">wallsplash-android MainActivity.java</h4>
<ul>
<li>Enum for Java<br />
  definitin of MainActivity.Category</li>
<li>materialdrawer<br />
  https://github.com/mikepenz/MaterialDrawer</li>
<li>OpenLibra-Material<br />
  https://github.com/saulmm/OpenLibra-Material</li>
<li>aboutlibraries<br />
  https://github.com/mikepenz/AboutLibraries</li>
<li>iconics<br />
  https://github.com/mikepenz/Android-Iconics</li>
</ul>
<h4 id="wallsplash-android-imagesfragmentjava">wallsplash-android ImagesFragment.java</h4>
<ul>
<li>RecyclerView -&gt; fragment_images.xml<br />
  A flexible view for providing a limited window into a large data set.<br />
  REF: GridLayoutManager, RecyclerView.Adapter</li>
<li>ActivityOptionsCompat<br />
  Helper for accessing features in android.app.ActivityOptions introduced in API level 16 in a backwards compatible fashion.</li>
<li>errorview<br />
  https://github.com/xiprox/ErrorView<br />
  A custom view that displays an error image, a title, and a subtitle given an HTTP status code.</li>
</ul>
<h4 id="wallsplash-android-unsplashapijava">wallsplash-android UnsplashApi.java</h4>
<ul>
<li>RxAndroid<br />
  https://github.com/ReactiveX/RxAndroid<br />
  Android specific bindings for RxJava</li>
<li>RxJava<br />
  https://github.com/ReactiveX/RxJava<br />
  RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM</li>
<li>retrofit<br />
  https://github.com/square/retrofit<br />
  Type-safe REST client for Android and Java by Square, Inc.</li>
<li>okhttp<br />
  https://github.com/square/okhttp<br />
  An HTTP+SPDY client for Android and Java applications.</li>
<li>Gson<br />
  https://github.com/google/gson<br />
  Gson is a Java library that can be used to convert Java Objects into their JSON representation. It can also be used to convert a JSON string to an equivalent Java object. Gson can work with arbitrary Java objects including pre-existing objects that you do not have source-code of.</li>
<li>API<br />
  http://wallsplash.lanora.io/pictures<br />
  http://wallsplash.lanora.io/random</li>
</ul>
<h2 id="20150423">20150423</h2>
<h4 id="_1">做成一件事情</h4>
<ul>
<li>选择一个方向：Android 进阶社区</li>
<li>持续输入价值：入门，进阶，疑难问题案例分析</li>
<li>持续运营：把文章/视频发到热闹的社区引流</li>
<li>想像空间：证明团队价值；与更大的世界发生交集；</li>
</ul>
<p><strong>注意点</strong>：专注；持续；快乐。忌朝三暮四，左顾右盼。</p>
<h2 id="20150419">20150419</h2>
<h4 id="android-performance-training">Android Performance Training</h4>
<ul>
<li>udacity.com 上来自 google 官方的原始资料<br />
  https://www.udacity.com/course/viewer#!/c-ud825/l-3729268966/m-3785788694</li>
<li>ChinaGDG from youku.com<br />
  整理出几个专题：主要是内存专题和电池专题。同归复习渲染和运算专题。<br />
  http://www.youku.com/playlist_show/id_23494296.html</li>
<li>通过示例现场演示几个工具的使用<br />
  Memory Monitor, Heap Viewer, Allocation Tracker</li>
<li>可参考的文章<br />
  hukai.me<br />
  http://hukai.me/android-performance-memory</li>
</ul>
<h2 id="20150607">20150607</h2>
<h4 id="_2">《持续的幸福》阅读笔记</h4>
<ul>
<li>幸福 1.0 vs 幸福 2.0<br />
  幸福 1.0 主要关注生活满意度，由积极情绪，投入和意义构成。而幸福 2.0 则由 PERMA 指标构成，具体就是积极情绪，投入，意义，成就，积极的人际关系。Seligman 教授认为，要让人生蓬勃发展，可以提高这五项指标来获得。</li>
<li>三件好事练习<br />
  从进化的角度来看，人是悲观偏好的，那些过分乐观的人活不过冰河世纪。如何克服悲观偏好，可以从三个好事练习着手。即每天记录三个好事，可以是大事（如获得升职），也可以是生活的小事（如发现一个好吃的饭馆）。然后写上这个事对你的影响或产生的原因。这样来引导自己多关注积极的事情。</li>
<li>突出优势练习<br />
  通过 www.authentichappiness.org 来测量自己的性格优势，通过发挥自己的性格优势来增加幸福感。</li>
<li>积极主动式回应 vs 消极主动式回应<br />
  女儿告诉我她在学校运动会上获得了一个奖牌。<br />
  积极主动：太棒了，你拿到奖牌时是什么感受？你的同学是什么反应？这个运动挺难的，平时没见你练啊，你怎么拿到奖牌的？<br />
  积极被动：哦，真厉害。<br />
  消极被动：我今天上班很累。<br />
  消极主动：不好好读书，拿个运动会奖牌干什么用，把时间花在学习上。</li>
<li>洛萨达比例<br />
  职场洛萨达比例在 3:1 以上时，公司的业务是蓬勃发展的。要获得良好的家庭生活，洛萨达比例需要达到 5:1。<br />
  洛萨达比例 (以其发现者 Marcel Losada 命名) 是指对所有的语言按照积极和消极进行编码，积极和消极的比例即洛萨达比例。</li>
<li>成就公式<br />
  成就 = 技能 x 努力。成就是一个矢量，而不是绝对距离。成就是朝一个特定的方向持续努力的结果。<br />
<strong>速度</strong>: 自动化的东西越多，速度越快，我们对该任务的知识就越多。<br />
<strong>缓慢</strong>: 成就中举足轻重，有意识的过程（如规划，精细化，检查错误和创造）。速度越快，知识越多，留给这些执行功能的时间就越多。<br />
<strong>学习速度</strong>: 新的信息能以多快的速度变为自动知识，以留给缓慢的执行过程更多的时间。</li>
<li>学习的速度<br />
  技能的学习是让我们获得一种自动化处理的能力。比如打字，刚开始的时候需要先想我们打什么字，这个字由哪几个字根组成，这些字根在哪个按键上，然后手指再按下这些按键。这是技能，当这项技能经过足够多的练习，变成一个自动化的过程后，打字就快很多了。因为头脑在想打哪个字的时候，手指已经直接按下能打出这个字所在的键盘了。这就是自动化处理能力。自动化处理能力可以大大提高效率。这也是一万小时天才理论的基础。学习的快，是指你能以多快的速度培养一项技能的自动化处理能力。</li>
<li>创伤后成长的五要素<br />
  1. 认识到创伤后信念崩塌是正常的反应；<br />
  2. 减少焦虑和强迫性的想法；<br />
  3. 讲出创作经历；<br />
  4. 描述创伤后积极的改变；<br />
  5. 总结因为创伤而产生的更加坚强，更加无惧挑战的人生原则和立场。<br />
<strong>那些杀不死我的，必将使我强大。</strong>&mdash;尼采</li>
<li>ABCDE 模式<br />
  情感的后果不是由不好的事情导致的，而是由你对这个事情的解读导致的。<br />
  Adversity -&gt; Belief -&gt; Consequence。Disputation 代表反驳，Energization 代表你成功进行反驳后受到的启发。</li>
<li>习得性无助<br />
  经历过束手无策的逆境，再遇到逆境时，就会变得消极被动，容易放弃。<br />
<strong>实验第一部份</strong><br />
  掌握组：老鼠经历 64 次可避免的电击。<br />
  无助组：老鼠经历 64 次无法避免电击。<br />
  对照组：没有受到电击。<br />
<strong>实验第二部分</strong>：注射有 50% 概率到死的癌细胞<br />
  掌握组：25% 死亡率<br />
  无助组：75% 死亡率<br />
  对照组：50% 死亡率</li>
</ul>
<h2 id="20160614">20160614</h2>
<p>Node.js Design Patterns: Chapeter 1 Node.js Design Fundamentals</p>
<p>异步和回调；模块系统；观察者模式等等</p>
<h3 id="the-nodejs-philosophy">The Node.js philosophy</h3>
<ul>
<li>Small Core: 微内核</li>
<li>Small Module: 小模块。解决了 dependency hell 问题，每个模块可以有自己独立的依赖模块列表。即一个软件可以依赖同一个模块的不同版本。</li>
<li>Small is beautiful.</li>
<li>Make each program do one thing well.</li>
<li>Easier to understand and use</li>
<li>Simpler to test and maintain</li>
<li>Perfect to share with the browser</li>
<li>Small surface area: 小接口。暴露出最小的，最重要的接口。次要的放在模块的属性，方法里。</li>
<li>暴露尽量少的接口 -&gt; 易于使用</li>
<li>模块设计的目的是为了被使用，而不是被扩展</li>
<li>Simplicity and pragmatism: 简单实用原则</li>
</ul>
<h2 id="20160615">20160615</h2>
<p>最高效的深度拷贝库: https://github.com/ivolovikov/fastest-clone</p>
<ul>
<li>javascript 元编程：利用 <code>new Function('params', 'function body')</code> 或 <code>eval('code')</code> 来进行实现函数</li>
<li>javascript 元编程：利用 <code>Function.prototype.call()</code> 或 <code>Function.prototype.apply()</code> 来对函数进行调用</li>
<li>判断是否在 node.js 环境： <code>if (typeof module == 'object' &amp;&amp; typeof module.exports == 'object')</code></li>
<li>递归获取 Object 实例的所有属性以及属性的属性：<code>_getKeyMap: function (source, deep, baseKey, arrIndex)</code></li>
</ul>
<p>Node.js Design Patterns: Chapeter 1 Node.js Design Fundamentals</p>
<h3 id="the-reactor-pattern">The reactor pattern</h3>
<ul>
<li>I/O is slow: 与内存访问速度在 GB/s 数量级；磁盘的访问速度在 MB/s 数量级。</li>
<li>Blocking I/O:　阻塞式访问 I/O ，需要用多线程机制来处理并发。需要增加线程锁和线程数据同步，增加了复杂性。</li>
<li>Non-blocking I/O: 使用非阻塞式 I/O 的一个方案是忙等待 (Busy Wait)，即不停地调用 I/O 函数，直到读出数据或出错为止。这种方案较浪费 CPU 。</li>
<li>Event demultiplexing: 多路事件分解器来提高使用非阻塞 I/O 的效率。把所有待监控的资源都放在一个数组里，交给事件分解器来监视，当资源上有事件发生（比如有数据可供读取）时，监视动作返回，再去读取数据。当没有事件发生时，监控函数会进入睡眠状态，把 CPU 让给别的程序。这一编程模式类似用 <code>select</code> 函数实现异步 Socket 编程。</li>
<li>The reactor pattern: 反应堆模式。比 Event demultiplexing 更进一步。直接给资源的操作提供一个 Handler 作为回调函数。当资源可用时，直接调用回调函数。实现完整的异步 I/O 编程模式。</li>
<li>libuv: The non-blocking I/O engine of Node.js。不同的操作系统有各种的 Event demultiplexing 机制，比如 Linux 下的 <code>epoll</code>，Mac OS X 下的 <code>kqueue</code>，Windows 下的 I/O Completion Port API (IOCP)。不同平台的事件分发机制不同，且同一个平台下不同的资源的异步模式也不同。比如 Unix 下 socket 支持异步 I/O，而普通的文件系统 API 则不支持异步 I/O，这个时候就需要用单独的线程来模拟异步文件读写操作。libuv 库就是为了解决这些问题而产生的。它向 javascript 提供了不同操作系统，不同资源的异步 I/O 的抽像封装和实现。</li>
<li>The recipe for Node.js: Node.js 包含以下几部分</li>
<li>操作系统底层接口的封装，并暴露给 javascript 调用，如 libuv 等</li>
<li>V8, 这是 Google 给 Chrome 开发的高性能的 javascript 引擎</li>
<li>node.js 核心库 (node-core)，实现 Node.js 的高层 API</li>
</ul>
<h2 id="20160616">20160616</h2>
<p>Node.js Design Patterns: Chapeter 1 Node.js Design Fundamentals</p>
<h3 id="the-callback-pattern">The callback pattern</h3>
<ul>
<li>The continuation-passing style: CPS 把函数作为参数传递，完成回调</li>
<li>Synchronous continuation-passing style：同步回调，即函数返回后，回调也己调用了。</li>
<li>Asynchronous continuation-passing style：异步回调，即函数返回后，回调还没被调用，回调会被推送到 event queue 里，在下一轮的 event loop 里调用回调。比如使用 <code>setTimeout()</code>， <code>process.nextTick()</code> 来实现。</li>
<li>Non continuation-passing style callbacks：非 CPS 方式的回调。比如 <code>Array.map()</code> 的回调函数，通过回调函数的返回值直接交互。</li>
<li>Synchronous or asynchronous?：同步还是异步？</li>
<li>An unpredictable function：同步和异步不可预见性，即<a href="#an_unpredictable_function">有时是同步回调，有时是异步回调</a>。这种问题会引入非常难查的 bug 。</li>
<li>Using synchronous APIs：改装成同步 API，比如通过 <code>fs.readFileSync()</code> 函数来实现。不推荐使用这种方式，会破坏 Node.js 的异步 I/O 模式。一个判断标准是：Use blocking API only when they don&rsquo;t affect the ability of the application to serve concurrent requests.</li>
<li>Deferred execution：延后执行，把 API 改装成异步回调。通过 <code>process.nextTick()</code> 实现。需要注意在 event loop 里的优先级。</li>
<li>Node.js callback conventions: Node.js 的回调惯例</li>
<li>Callbacks come last: 把回调放在最后一个参数，这样在使用的时候，可以直接用匿名函数或箭头函数实现。如 <code>fs.readFile(filename, [options], callback)</code> 。</li>
<li>Error comes first: 把错误放在第一个参数。在 Node.js 里，CPS 风格的回调的第一个参数通常是错误信息，数据结果在第二个及之后的参数提供。如果没有出错，第一个参数的值为 <code>null</code> 或 <code>undefined</code> 。如 <code>fs.readFile('foo.txt', 'utf8', function(err, data) {}</code> 。</li>
<li>Propagating errors: 错误传递机制。同步调用时，错误传递机制通过 <code>throw</code> 来抛出异常，这样可以使错误在调用栈里往上跳，直到它被处理为止。而在异常调用里，异常处理的机制是，在 CPS 回调链里，通过回调函数一层层往上传递。可参阅<a href="#propagating_errors">示例代码</a>。</li>
<li>Uncaught exceptions: 未处理的异常可以通过 <code>process.on('uncaughtException', function(err){}</code> 来捕获到。系统默认是直接退出程序。一般的处理是在这里记录异步 Log ，然后退出程序。针对网络服务而言，退出程序重启总是保证持续服务可用的一个折衷策略。</li>
</ul>
<p><a name="an_unpredictable_function"></a><strong>同步或异步不可预测的函数</strong></p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">var</span> fs <span style="color: #666666">=</span> require(<span style="color: #BB4444">&#39;fs&#39;</span>);
<span style="color: #AA22FF; font-weight: bold">var</span> cache <span style="color: #666666">=</span> {};
<span style="color: #AA22FF; font-weight: bold">function</span> inconsistentRead(filename, callback) {
  <span style="color: #AA22FF; font-weight: bold">if</span>(cache[filename]) {
    <span style="color: #008800; font-style: italic">//invoked synchronously</span>
    callback(cache[filename]);
  } <span style="color: #AA22FF; font-weight: bold">else</span> {
    <span style="color: #008800; font-style: italic">//asynchronous function</span>
    fs.readFile(filename, <span style="color: #BB4444">&#39;utf8&#39;</span>, <span style="color: #AA22FF; font-weight: bold">function</span>(err, data) {
      cache[filename] <span style="color: #666666">=</span> data;
      callback(data);
    });
  }
}
</pre></div>


<p><a name="propagating_errors"></a><strong>异步回调的异常处理</strong></p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">var</span> fs <span style="color: #666666">=</span> require(<span style="color: #BB4444">&#39;fs&#39;</span>);
<span style="color: #AA22FF; font-weight: bold">function</span> readJSON(filename, callback) {
  fs.readFile(filename, <span style="color: #BB4444">&#39;utf8&#39;</span>, <span style="color: #AA22FF; font-weight: bold">function</span>(err, data) {
    <span style="color: #AA22FF; font-weight: bold">var</span> parsed;
    <span style="color: #AA22FF; font-weight: bold">if</span>(err)
      <span style="color: #008800; font-style: italic">//propagate the error and exit the current function</span>
      <span style="color: #AA22FF; font-weight: bold">return</span> callback(err);
    <span style="color: #AA22FF; font-weight: bold">try</span> {
      <span style="color: #008800; font-style: italic">//parse the file contents</span>
      parsed <span style="color: #666666">=</span> JSON.parse(data);
    } <span style="color: #AA22FF; font-weight: bold">catch</span>(err) {
      <span style="color: #008800; font-style: italic">//catch parsing errors</span>
      <span style="color: #AA22FF; font-weight: bold">return</span> callback(err);
    }
    <span style="color: #008800; font-style: italic">//no errors, propagate just the data</span>
    callback(<span style="color: #AA22FF; font-weight: bold">null</span>, parsed);
  });
};
</pre></div>


<h2 id="20160620">20160620</h2>
<p>Node.js Design Patterns: Chapeter 1 Node.js Design Fundamentals</p>
<h3 id="the-module-system-and-its-patterns">The module system and its patterns</h3>
<p>模块系统是 Node.js 的代码结构化的基础，实现信息隐藏和接口实现的功能。</p>
<ul>
<li>The revealing module pattern: 模块系统的本质是利用函数来创建具有信息隐藏功能的代码块。函数内的嵌套函数及变量对模块外部不可见，只有函数返回的属性和方法才对外可见。</li>
<li>Node.js modules explained: 官方文档 <a href="https://nodejs.org/api/modules.html">Node.js 模块系统</a> 是最权威且最清晰的资料。</li>
<li>module.exports vs exports: The variable exports is just a reference to the initial value of module. exports。</li>
<li>require is synchronous</li>
<li>The resolving algorithm</li>
<li>File modules: 以 <code>/</code> 或 <code>./</code> 或 <code>../</code> 开头的参数，解释为文件模块</li>
<li>Core modules: 如果没有以路径开头，则解释为 Node.js 核心内置模块，如 <code>var fs = require(fs);</code> 。</li>
<li>Package modules: 如果没有核心模块与之匹配，则查找当前目录下的 <code>node_modules</code> 目录下查找匹配的模块，如果找不到，则查找从父目录的 <code>node_modules</code> 目录下查找，直至根目录下的 <code>node_modules</code> 。</li>
<li>文件模块/包模块匹配策略<ul>
<li><code>moduleName.js</code></li>
<li><code>moduleName/index.js</code></li>
<li>The <code>main</code> property of <code>moduleName/package.json</code></li>
</ul>
</li>
<li>Solution for <strong>Dependency Hell</strong>: 按照上述模块搜索算法，每个模块都可以通过自己的 <code>node_modules</code> 子目录指定其依赖的子模块。这样即使同一个应用程序里不同模块引用了相同的子模块，他们各自独立，可以是不同的版本。</li>
<li>The module cache: 模块缓存可以解决几个问题</li>
<li>循环引用问题</li>
<li>确保引用的一致性</li>
<li>加快效率</li>
<li>Cycles: 模块循环引用问题，A require B, B require A</li>
<li>Module de nition patterns</li>
<li>Named exports: <code>exports.info = function(message) { ... }</code></li>
<li>Exporting a function: <code>module.exports = function(message) { ... }</code></li>
<li>Exporting a constructor: <a href="#exporting_a_constructor">示例代码</a></li>
<li>Exporting an instance: <a href="#exporting_an_instance">示例代码</a>。巧妙地利用模块的缓存功能，使每个引用此模块的模块都引用了同一个实例。这样就实现了单例 (Singleton) 模式。</li>
<li>Modifying other modules or the global scope: 不是好的实践，但在自动测试领域有其应用场景，我们称之为猴子补丁 (Monkey Patching) 。<a href="#monkey_patching">示例代码</a> 。</li>
</ul>
<p><a name="exporting_a_constructor"></a><strong>模块返回构造函数</strong></p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008800; font-style: italic">//file logger.js</span>
<span style="color: #AA22FF; font-weight: bold">function</span> Logger(name) {
 <span style="color: #AA22FF; font-weight: bold">this</span>.name <span style="color: #666666">=</span> name;
};
Logger.prototype.log <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">function</span>(message) {
 console.log(<span style="color: #BB4444">&#39;[&#39;</span> <span style="color: #666666">+</span> <span style="color: #AA22FF; font-weight: bold">this</span>.name <span style="color: #666666">+</span> <span style="color: #BB4444">&#39;] &#39;</span> <span style="color: #666666">+</span> message);
};
Logger.prototype.info <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">function</span>(message) {
 <span style="color: #AA22FF; font-weight: bold">this</span>.log(<span style="color: #BB4444">&#39;info: &#39;</span> <span style="color: #666666">+</span> message);
};
Logger.prototype.verbose <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">function</span>(message) {
 <span style="color: #AA22FF; font-weight: bold">this</span>.log(<span style="color: #BB4444">&#39;verbose: &#39;</span> <span style="color: #666666">+</span> message);
};
module.exports <span style="color: #666666">=</span> Logger;
</pre></div>


<p><a name="exporting_an_instance"></a><strong>模块返回一个实例/单例</strong></p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008800; font-style: italic">// file logger.js</span>
<span style="color: #AA22FF; font-weight: bold">function</span> Logger(name) {
  <span style="color: #AA22FF; font-weight: bold">this</span>.count <span style="color: #666666">=</span> <span style="color: #666666">0</span>;
  <span style="color: #AA22FF; font-weight: bold">this</span>.name <span style="color: #666666">=</span> name;
};

Logger.prototype.log <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">function</span>(message) {
  <span style="color: #AA22FF; font-weight: bold">this</span>.count<span style="color: #666666">++</span>;
  console.log(<span style="color: #BB4444">&#39;[&#39;</span> <span style="color: #666666">+</span> <span style="color: #AA22FF; font-weight: bold">this</span>.name <span style="color: #666666">+</span> <span style="color: #BB4444">&#39;] &#39;</span> <span style="color: #666666">+</span> message);
};
module.exports <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">new</span> Logger(<span style="color: #BB4444">&#39;DEFAULT&#39;</span>);
</pre></div>


<p><a name="monkey_patching"></a><strong>猴子补丁</strong></p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008800; font-style: italic">// file patcher.js</span>
<span style="color: #008800; font-style: italic">// ./logger is another module</span>
require(<span style="color: #BB4444">&#39;./logger&#39;</span>).customMessage <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">function</span>() {
  console.log(<span style="color: #BB4444">&#39;This is a new functionality&#39;</span>);
};

<span style="color: #008800; font-style: italic">// Using our new patcher module would be as easy as writing the following code:</span>
<span style="color: #008800; font-style: italic">// file main.js</span>
require(<span style="color: #BB4444">&#39;./patcher&#39;</span>);
<span style="color: #AA22FF; font-weight: bold">var</span> logger <span style="color: #666666">=</span> require(<span style="color: #BB4444">&#39;./logger&#39;</span>);
logger.customMessage();
</pre></div>


<h2 id="20160621">20160621</h2>
<h3 id="rethinkdb">rethinkdb</h3>
<p>提供在线数据库，提供数据的增删改查。一大亮眼特性是 changefeed。它能够把数据库中某个查询结果集的改变 publish 出来，供其他人 subscribe。这个特性对 realtime collaboration 的 app 来说非常有用。可以实现数据实时同步。</p>
<p>什么样的场景适合使用 rethinkdb ?</p>
<ul>
<li>Collaborative web and mobile apps</li>
<li>Streaming analytics apps</li>
<li>Multiplayer games</li>
<li>Realtime marketplaces</li>
<li>Connected devices</li>
</ul>
<h3 id="leancloud">leancloud</h3>
<p>提供在线非结构化数据库，提供数据的增删改查。辅助类，提供实时聊天及推送，流量分析等功能。</p>
<h3 id="wilddog">wilddog</h3>
<p>国内的 BaaS (Backend as a Service) 平台。提供两大功能：</p>
<ul>
<li>实时同步: 提供毫秒级实时数据同步。使用 TLS + websocket 保障通信安全。不支持 websocket 的环境使用 long-polling 模拟长连接。保障通信实时性。即一个数据修改后，另外一个订阅者可以马上得到同步。</li>
<li>在线 Json 数据库：提供数据的增删改查功能。</li>
</ul>
<h3 id="iot">带网关的 IoT 系统通信需求</h3>
<ul>
<li>安全性：通信安全 (TLS) 及访问授权 (Auth)</li>
<li>实时性：控制命令和状态能及时送达，达到毫秒级实时性</li>
<li>双向通信：不同于 request/response 响应模型。App 与 Gateway，App 与 Server 之间必须支持双向实时通信。</li>
<li>一致性：App 与 Gateway 之间；App 与 Server 之间需要实现一致的通信协议和通信模型，减少系统复杂度和开发工作量。</li>
</ul>
<h3 id="websocket-long-polling">websocket &amp; long-polling</h3>
<ul>
<li><a href="http://tools.ietf.org/html/rfc6455">RFC 6455 - The WebSocket Protocol</a></li>
<li><a href="http://www.w3.org/TR/websockets/">WebSocket API Specification</a></li>
<li><a href="http://socket.io">socket.io</a>: A powerful cross-platform WebSocket API for Node.js</li>
</ul>
<h3 id="xaas">XaaS</h3>
<blockquote>
<p>传统云服务公司的定义：SaaS、PaaS、IaaS。越往下自由度越高，越往上使用起来越简单。<br />
SaaS解决的是开箱即用的问题，不用写代码，直接用。PaaS解决的是运维的问题，写完代码往云端一扔，搞定。而IaaS解决的是硬件资源弹性扩容的问题，像个水龙头，用多少拧多少。<br />
目前PaaS代表的产品比如HeroKu，Google App Engine、国内SAE等，几乎全线已挂或半死不活。PaaS挂掉的原因是没有解决根本问题，半吊子。又不简单，又不自由。<br />
广义BaaS是指用户需要通过远程API获得服务的云服务产品。比如类似统计服务MixPanel、友盟等。狭义的BaaS是指通过远程API提供计算和存储资源的产品，比如Parse、Firebase、Twilio、Pusher，Apple Cloud Kit这样的产品。</p>
</blockquote>
<p>REF: http://www.leiphone.com/news/201605/UQ4LxnsXfxqv2r39.html</p>
<h2 id="20160622">20160622</h2>
<p>Node.js Design Patterns: Chapeter 1 Node.js Design Fundamentals</p>
<h3 id="the-observer-pattern">The observer pattern</h3>
<p>The observer pattern is already built into the Node.js core and is available through the <code>EventEmitter</code> class.</p>
<ul>
<li>EventEmitter 类的用法，可以手动创建一个 <code>EventEmitter</code> 实例来使用。</li>
<li>错误处理：不能直接抛出异常，因为事件回调一般在单独的消息循环里处理，抛出的异常会丢失。一个通用的做法是定义一个独立的 <code>error</code> 事件，然后 <code>emmit</code> 这个事件。</li>
<li>Make any object observable：通过继承 <code>EventMitter</code> 来实现。ES5 可以通过 <code>util.inherits()</code> 实现，ES6 可以直接用 <code>inherit</code> 关键字实现。</li>
<li>Synchronous and asynchronous events: 同步事件和异常事件</li>
<li>EventEmitter vs Callbacks: 应该用哪个呢？</li>
<li>semantic: callbacks should be used when a result must be returned in an asynchronous way; events should instead be used when there is a need to communicate that something has just happened.</li>
<li>如果一个事件可能发生多次，或者可能根本不会发生，使用 EventEmitter 是较好的选择</li>
<li>使用 EventEmitter 可以让多个监听者同时监听到事件。而 callback 是一对一的结果返回。</li>
<li>Combine callbacks and EventEmitter: 结合两者的优势。</li>
</ul>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">var</span> glob <span style="color: #666666">=</span> require(<span style="color: #BB4444">&#39;glob&#39;</span>);
glob(<span style="color: #BB4444">&#39;data/*.txt&#39;</span>, <span style="color: #AA22FF; font-weight: bold">function</span>(error, files) {
  console.log(<span style="color: #BB4444">&#39;All files found: &#39;</span> <span style="color: #666666">+</span> JSON.stringify(files));
}).on(<span style="color: #BB4444">&#39;match&#39;</span>, <span style="color: #AA22FF; font-weight: bold">function</span>(match) {
  console.log(<span style="color: #BB4444">&#39;Match found: &#39;</span> <span style="color: #666666">+</span> match);
});
</pre></div>


<p>关于 <code>EventEmitter</code> 可参阅<a href="https://nodejs.org/dist/latest-v6.x/docs/api/events.html">官方资料</a> 。</p>
<h2 id="20160624">20160624</h2>
<p>Node.js Design Patterns: Chapeter 2 Asynchronous Control Flow Patterns</p>
<h3 id="the-difficulties-of-asynchronous-programming">The difficulties of asynchronous programming</h3>
<p><strong>The callback hell</strong>: 使用 <code>request</code> 和 <code>mkdirp</code> 实现的一个简单的爬虫程序，可以明显地看到异步流程控制代码很容易陷入 callback hell 的陷阱。如<a href="#callback_hell">示例程序</a>。callback hell 的代码有如下问题：</p>
<ul>
<li>可读性差：很难界定回调函数的起始位置和结束位置</li>
<li>变量名重叠：比如回调函数里的错误码 <code>err</code> 在每个回调函数里都有，容易引起误解</li>
<li>闭包函数会引起少量的内存和性能问题，比如内存泄露</li>
</ul>
<p><a name="callback_hell"></a><strong>爬虫程序：callback hell</strong></p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">function</span> spider(url, callback) {
    <span style="color: #AA22FF; font-weight: bold">var</span> filename <span style="color: #666666">=</span> utilities.urlToFilename(url);
    fs.exists(filename, <span style="color: #AA22FF; font-weight: bold">function</span>(exists) {                              <span style="color: #008800; font-style: italic">//[1]</span>
        <span style="color: #AA22FF; font-weight: bold">if</span>(<span style="color: #666666">!</span>exists) {
            console.log(<span style="color: #BB4444">&quot;Downloading &quot;</span> <span style="color: #666666">+</span> url);
            request(url, <span style="color: #AA22FF; font-weight: bold">function</span>(err, response, body) {                <span style="color: #008800; font-style: italic">//[2]</span>
                <span style="color: #AA22FF; font-weight: bold">if</span>(err) {
                    callback(err);
                } <span style="color: #AA22FF; font-weight: bold">else</span> {
                    mkdirp(path.dirname(filename), <span style="color: #AA22FF; font-weight: bold">function</span>(err) {      <span style="color: #008800; font-style: italic">//[3]</span>
                        <span style="color: #AA22FF; font-weight: bold">if</span>(err) {
                            callback(err);
                        } <span style="color: #AA22FF; font-weight: bold">else</span> {
                            fs.writeFile(filename, body, <span style="color: #AA22FF; font-weight: bold">function</span>(err) { <span style="color: #008800; font-style: italic">//[4]</span>
                                <span style="color: #AA22FF; font-weight: bold">if</span>(err) {
                                    callback(err);
                                } <span style="color: #AA22FF; font-weight: bold">else</span> {
                                    callback(<span style="color: #AA22FF; font-weight: bold">null</span>, filename, <span style="color: #AA22FF; font-weight: bold">true</span>);
                                } });
                        } });
                } });
        } <span style="color: #AA22FF; font-weight: bold">else</span> {
            callback(<span style="color: #AA22FF; font-weight: bold">null</span>, filename, <span style="color: #AA22FF; font-weight: bold">false</span>);
        } });
}
</pre></div>


<h3 id="using-plain-javascript">Using plain JavaScript</h3>
<p>使用 JavaScript 的一些通用规则可以避免 callback hell 问题。</p>
<p><strong>Callback discipline</strong>: 编写回调函数的一些原则</p>
<ul>
<li>You must exit as soon as possible. 尽早返回。即先处理错误。</li>
<li>You need to create named functions for callbacks. 给回调创建命名函数。</li>
<li>You need to modularize the code. Split the code into smaller, reusable functions whenever it&rsquo;s possible.</li>
</ul>
<p>下面是按照编写回调函数的原则执行后的改进版本：</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">function</span> saveFile(filename, contents, callback) {
    mkdirp(path.dirname(filename), <span style="color: #AA22FF; font-weight: bold">function</span>(err) {
        <span style="color: #AA22FF; font-weight: bold">if</span>(err) {
            <span style="color: #AA22FF; font-weight: bold">return</span> callback(err);
        }
        fs.writeFile(filename, contents, callback);
    });
}

<span style="color: #AA22FF; font-weight: bold">function</span> download(url, filename, callback) {
    console.log(<span style="color: #BB4444">&#39;Downloading &#39;</span> <span style="color: #666666">+</span> url);
    request(url, <span style="color: #AA22FF; font-weight: bold">function</span>(err, response, body) {
        <span style="color: #AA22FF; font-weight: bold">if</span>(err) {
            <span style="color: #AA22FF; font-weight: bold">return</span> callback(err);
        }
        saveFile(filename, body, <span style="color: #AA22FF; font-weight: bold">function</span>(err) {
            console.log(<span style="color: #BB4444">&#39;Downloaded and saved: &#39;</span> <span style="color: #666666">+</span> url);
            <span style="color: #AA22FF; font-weight: bold">if</span>(err) {
                <span style="color: #AA22FF; font-weight: bold">return</span> callback(err);
            }
            callback(<span style="color: #AA22FF; font-weight: bold">null</span>, body);
        });
    });
}

<span style="color: #AA22FF; font-weight: bold">function</span> spider(url, callback) {
    <span style="color: #AA22FF; font-weight: bold">var</span> filename <span style="color: #666666">=</span> utilities.urlToFilename(url);
    fs.exists(filename, <span style="color: #AA22FF; font-weight: bold">function</span>(exists) {
        <span style="color: #AA22FF; font-weight: bold">if</span>(exists) {
            <span style="color: #AA22FF; font-weight: bold">return</span> callback(<span style="color: #AA22FF; font-weight: bold">null</span>, filename, <span style="color: #AA22FF; font-weight: bold">false</span>);
        }
        download(url, filename, <span style="color: #AA22FF; font-weight: bold">function</span>(err) {
            <span style="color: #AA22FF; font-weight: bold">if</span>(err) {
                <span style="color: #AA22FF; font-weight: bold">return</span> callback(err);
            }
            callback(<span style="color: #AA22FF; font-weight: bold">null</span>, filename, <span style="color: #AA22FF; font-weight: bold">true</span>);
        })
    });
}
</pre></div>


<p><strong>Sequential execution</strong>: 顺序执行</p>
<p>爬虫程序就是一个典型的顺序执行的程序。文件是否存在 -&gt; 从网络下载 -&gt; 新建文件夹 -&gt; 写文件。对己知的顺序执行的异步任务，可以使用下面的代码模板：</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">function</span> task1(callback) {
    asyncOperation(<span style="color: #AA22FF; font-weight: bold">function</span>() {
        Start Task <span style="color: #666666">1</span> Task <span style="color: #666666">2</span> Task <span style="color: #666666">3</span> End
        task2(callback);
    });
}

<span style="color: #AA22FF; font-weight: bold">function</span> task2(callback) {
    asyncOperation(<span style="color: #AA22FF; font-weight: bold">function</span>(result) {
        task3(callback);
    });
}

<span style="color: #AA22FF; font-weight: bold">function</span> task3(callback) {
    asyncOperation(<span style="color: #AA22FF; font-weight: bold">function</span>() {
        callback();
    });
}

task1(<span style="color: #AA22FF; font-weight: bold">function</span>() {
    <span style="color: #008800; font-style: italic">//task1, task2, task3 completed</span>
});
</pre></div>


<p><strong>Sequential iteration</strong>: 异步遍历序列数据</p>
<ul>
<li><code>task()</code> 函数最好是异步函数，如果是同步函数，可能造成深度递归，从而使栈溢出</li>
</ul>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">function</span> iterate(index) {
    <span style="color: #AA22FF; font-weight: bold">if</span>(index <span style="color: #666666">===</span> tasks.length)  {
        <span style="color: #AA22FF; font-weight: bold">return</span> finish();
    }
    <span style="color: #AA22FF; font-weight: bold">var</span> task <span style="color: #666666">=</span> tasks[index];
    task(<span style="color: #AA22FF; font-weight: bold">function</span>() {
        iterate(index <span style="color: #666666">+</span> <span style="color: #666666">1</span>);
    });
}

<span style="color: #AA22FF; font-weight: bold">function</span> finish() {
    <span style="color: #008800; font-style: italic">//iteration completed</span>
}

iterate(<span style="color: #666666">0</span>);   <span style="color: #008800; font-style: italic">// start iterate sequence asynchronize</span>
</pre></div>


<p><strong>思考</strong></p>
<ul>
<li>使用异步遍历序列数据的方法，实现爬虫的另外一个版本：递归下载网页和网页里的所有链接。注意，只下载相同域名下的链接。</li>
<li>更一般化地抽你异步遍历模型，可以实现如下函数签名的异步遍历函数 <code>iterateSeries(collection, iteratorCallback, finalCallback)</code> 。</li>
</ul>
<h2 id="20160627">20160627</h2>
<p>Node.js Design Patterns: Chapeter 2 Asynchronous Control Flow Patterns</p>
<h3 id="parallel-execution">Parallel execution</h3>
<p>如果多个任务没有先后顺序上的依赖，那么可以使用并行执行的模型来实现。当任务全部完成后，通过回调函数通知调用者。</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">var</span> tasks <span style="color: #666666">=</span> [...];
<span style="color: #AA22FF; font-weight: bold">var</span> completed <span style="color: #666666">=</span> <span style="color: #666666">0</span>;

tasks.forEach(<span style="color: #AA22FF; font-weight: bold">function</span>(task) {
    task(<span style="color: #AA22FF; font-weight: bold">function</span>() {
        <span style="color: #AA22FF; font-weight: bold">if</span>(<span style="color: #666666">++</span>completed <span style="color: #666666">===</span> tasks.length) {
            finish(); }
    });
});

<span style="color: #AA22FF; font-weight: bold">function</span> finish() {
    <span style="color: #008800; font-style: italic">//all the tasks completed</span>
}
</pre></div>


<h2 id="20160630">20160630</h2>
<p>Node.js Design Patterns: Chapeter 2 Asynchronous Control Flow Patterns</p>
<h3 id="limiting-the-concurrency">Limiting the concurrency</h3>
<p>带上限的并发执行可以有效地控制资源消耗，避免资源过载。</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">var</span> tasks <span style="color: #666666">=</span> [...];
<span style="color: #AA22FF; font-weight: bold">var</span> concurrency <span style="color: #666666">=</span> <span style="color: #666666">2</span>, running <span style="color: #666666">=</span> <span style="color: #666666">0</span>, completed <span style="color: #666666">=</span> <span style="color: #666666">0</span>, index <span style="color: #666666">=</span> <span style="color: #666666">0</span>;

<span style="color: #AA22FF; font-weight: bold">function</span> next() {              <span style="color: #008800; font-style: italic">//[1]</span>
    <span style="color: #AA22FF; font-weight: bold">while</span>(running <span style="color: #666666">&lt;</span> concurrency <span style="color: #666666">&amp;&amp;</span> index <span style="color: #666666">&lt;</span> tasks.length) {
        task <span style="color: #666666">=</span> tasks[index<span style="color: #666666">++</span>];
        task(<span style="color: #AA22FF; font-weight: bold">function</span>() {            <span style="color: #008800; font-style: italic">//[2]</span>
            <span style="color: #AA22FF; font-weight: bold">if</span>(completed <span style="color: #666666">===</span> tasks.length) {
                <span style="color: #AA22FF; font-weight: bold">return</span> finish();
            }
            completed<span style="color: #666666">++</span>, running<span style="color: #666666">--</span>;
            next();
        });
        running<span style="color: #666666">++</span>;
    }
}

next();

<span style="color: #AA22FF; font-weight: bold">function</span> finish() {
    <span style="color: #008800; font-style: italic">//all tasks finished</span>
}
</pre></div>


<h3 id="globally-limiting-the-concurrency">Globally limiting the concurrency</h3>
<p>上面的模式无法实现全局限制，如果一个任务产生两个并发任务，多个任务就会产生多个并发任务。我们需要实现全局并发数量限制，可以用一个队列来实现。</p>
<p><a name="globally_limiting_the_concurrency"></a><strong>全局限制并发数量</strong></p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">function</span> TaskQueue (concurrency) {
    <span style="color: #AA22FF; font-weight: bold">this</span>.concurrency <span style="color: #666666">=</span> concurrency;
    <span style="color: #AA22FF; font-weight: bold">this</span>.running <span style="color: #666666">=</span> <span style="color: #666666">0</span>;
    <span style="color: #AA22FF; font-weight: bold">this</span>.queue <span style="color: #666666">=</span> [];
}

TaskQueue.prototype.pushTask <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">function</span> (task, callback) {
    <span style="color: #AA22FF; font-weight: bold">this</span>.queue.push([task, callback]);
    <span style="color: #AA22FF; font-weight: bold">this</span>.nextTask();
};

TaskQueue.prototype.nextTask <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">function</span> () {

    <span style="color: #AA22FF; font-weight: bold">function</span> makeCallback(self, task, callback) {
        <span style="color: #AA22FF; font-weight: bold">return</span> <span style="color: #AA22FF; font-weight: bold">function</span> (err) {
            callback(err, task);
            self.running <span style="color: #666666">--</span>;
            self.nextTask();
        }
    }

    <span style="color: #AA22FF; font-weight: bold">while</span> (<span style="color: #AA22FF; font-weight: bold">this</span>.running <span style="color: #666666">&lt;</span> <span style="color: #AA22FF; font-weight: bold">this</span>.concurrency <span style="color: #666666">&amp;&amp;</span> <span style="color: #AA22FF; font-weight: bold">this</span>.queue.length <span style="color: #666666">&gt;</span> <span style="color: #666666">0</span>) {
        <span style="color: #AA22FF; font-weight: bold">var</span> [task, callback] <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">this</span>.queue.shift();
        task(makeCallback(<span style="color: #AA22FF; font-weight: bold">this</span>, task, callback));
        <span style="color: #AA22FF; font-weight: bold">this</span>.running <span style="color: #666666">++</span>;
    }
};

module.exports <span style="color: #666666">=</span> TaskQueue;
</pre></div>


<p>具体 <code>TaskQueue</code> 代码可<a href="https://github.com/kamidox/exercism/tree/master/javascript/task-queue">参阅 GitHub 上的源码</a>。</p>
<h2 id="20160704">20160704</h2>
<p>Node.js Design Patterns: Chapeter 2 Asynchronous Control Flow Patterns</p>
<h3 id="the-async-library">The async library</h3>
<p><a href="https://npmjs.org/package/async">async</a> 已经成为 JavaScriopt 异步流程控制的事实标准。它最初设计目标是运行在 Node.js 环境，目前也可以在浏览器环境执行。</p>
<p><strong>Sequential execution</strong></p>
<p>async 库有 20 多个函数用来执行串行任务。<a href="http://caolan.github.io/async/docs.html#.series"><code>series()</code></a> 函数确保异步函数顺序执行；<a href="http://caolan.github.io/async/docs.html#.waterfall"><code>waterfall()</code> </a> 在确保异步函数顺序执行的同时，还会以上一个函数的输出作为下一个函数的输入。</p>
<p><strong>Parallel execution</strong></p>
<p>async 库有大量的并行异步任务控制器。比如 <code>map()</code> 从一个列表逐个元素映射，生成一个新列表，在列表元素映射的过程中，是并行发生的，所以没有顺序保证。<code>parallel()</code> 只是单纯地确保任务并行执行。</p>
<p><strong>Limited parallel execution</strong></p>
<p>async 也可以限制并发个数的并行执行。典型地，<code>parallel()</code> 有个对应的 <code>parallelLimit()</code> 函数，作为并发个数限制的版本。<code>queue()</code> 作为任务队列，和书中介绍过的 <code>TaskQueue</code> 完成类似的功能。</p>
<h3 id="promises">Promises</h3>
<h4 id="what-is-a-promise">What is a promise?</h4>
<p>Promises 是一种抽像，它允许异步函数返回一个 Promises 对象，用这个对象来表达异步函数的最终结果。用 Promises 术语来讲，当异步函数未完成时，这个 Promises 对象处于 <strong>未决 (pending)</strong> 状态。当异步函数成功完成时，这个 Promises 对象处于 <strong>达成 (fulfilled)</strong> 状态。当异步任务发生错误时，这个 Promises 对象处于 <strong>驳回 (rejected)</strong> 状态。只要异步函数完成，不管是成功还是失败，我们称这个 Promises 对象为 <strong>确定 (settled)</strong> 状态，这个状态和未决状态相对应。</p>
<p>In very simple terms, promises are an abstraction that allow an asynchronous function to return an object called a promise, which represents the eventual result of the operation. In the promises jargon, we say that a promise is pending when the asynchronous operation is not yet complete, it&rsquo;s fulfilled when the operation successfully completes, and rejected when the operation terminates with an error. Once a promise is either fulfilled or rejected, it&rsquo;s considered settled.</p>
<p>Promises 对象有个重要的方法 <code>then()</code> 可以用来处理异步代码。</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%">promise.then([onFulfilled], [onRejected])
</pre></div>


<p><code>onFulfilled</code> 是一个函数，用来处理达成状态的 Promises。<code>onRejected</code> 用来处理驳回状态的 Promises。</p>
<p>利用这一特性，可以把 CPS 回调转换为 Promises 异步处理方式：</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%">asyncOperation(arg, <span style="color: #AA22FF; font-weight: bold">function</span>(err, result) {
    <span style="color: #AA22FF; font-weight: bold">if</span>(err) {
        <span style="color: #008800; font-style: italic">//handle error</span>
    }
    <span style="color: #008800; font-style: italic">//do stuff with result</span>
});

asyncOperation(arg)
    .then(<span style="color: #AA22FF; font-weight: bold">function</span>(result) {
        <span style="color: #008800; font-style: italic">//do stuff with result</span>
    }, <span style="color: #AA22FF; font-weight: bold">function</span>(err) {
        <span style="color: #008800; font-style: italic">//handle error</span>
    });
</pre></div>


<p>用 Promises 写的代码更简洁，结构化现强。但这不是 Promises 的主要功能。<strong>Promises 的神奇功能在于 <code>then</code> 函数本身返回一个 Promises 对象</strong>。 <code>then</code> 函数的函数 <code>onFullfilled</code> 和 <code>onRejected</code> 什么时候被调用？在异步函数处于 settled 状态时被调用。如果 <code>onFulfilled</code> 或 <code>onRejected</code> 函数返回一个对象 <code>x</code>，那么 <code>then</code> 函数返回的 Promises 对象具有以下特性：</p>
<ul>
<li>如果 <code>x</code> 是一个值，那么 <code>then</code> 返回的 Promises 对象处于<strong>达成</strong>状态，且其值为 <code>x</code></li>
<li>如果 <code>x</code> 是一个 Promises 对象，那么 <code>then</code> 返回的 Promises 对象将会<strong>达成</strong> <code>x</code> 所达成的状态</li>
<li>如果 <code>x</code> 是一个 Promises 对象，那么 <code>then</code> 返回的 Promises 对象将会<strong>驳回</strong> <code>x</code> 所最终驳回的状态</li>
</ul>
<p>这一特性的重要性在于我们可以写出链式的 Promises 表达式。如果我们不指定 <code>onFulfilled</code> 或 <code>onRejected</code> ，那么 Promises 对象会自动把确定的状态 (达成或驳回) 传递给下一个 Promises 对象。这样我们可以非常方便地把错误处理传递下去，直到最后一环的 <code>onRejected</code> 函数中处理即可。</p>
<p>使用这个编程模型，顺序执行的异步函数可以写得非常简洁：</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%">asyncOperation(arg)
    .then(<span style="color: #AA22FF; font-weight: bold">function</span>(result1) {
        <span style="color: #008800; font-style: italic">//returns another promise</span>
        <span style="color: #AA22FF; font-weight: bold">return</span> asyncOperation(arg2);
    })
    .then(<span style="color: #AA22FF; font-weight: bold">function</span>(result2) {
        <span style="color: #008800; font-style: italic">//returns a value</span>
        <span style="color: #AA22FF; font-weight: bold">return</span> <span style="color: #BB4444">&#39;done&#39;</span>;
    })
    .then(<span style="color: #AA22FF; font-weight: bold">undefined</span>, <span style="color: #AA22FF; font-weight: bold">function</span>(err) {
        <span style="color: #008800; font-style: italic">//any error in the chain is caught here</span>
    });
</pre></div>


<p>关于链式 Promises 的工作流程，可以参阅下图：</p>
<p><img alt="Promises Chain" src="../../images/accumulate_promises_chain.png" /></p>
<p>另外一个特性是，Promises 对象的 <code>then</code> 函数总是确保 <code>onFulfilled</code> 和 <code>onRejected</code> 被异步调用。即使一个 Promises 对象是由一个同步函数返回的，也是如此。这样就确保了调用的一致性，避免出现<a href="#an_unpredictable_function">同步异步不可预测性的问题</a>。这种问题最典型的情况是，不知道函数的调用顺序。</p>
<h4 id="promisesa-implementations">Promises/A+ implementations</h4>
<p><a href="https://promisesaplus.com">Promises/A+</a> 是 ES6 Promises 采纳的实现标准。除此之外，还有一系列第三方库实现了 Promises/A+ 标准：</p>
<ul>
<li>Bluebird (https://npmjs.org/package/bluebird)</li>
<li>Q (https://npmjs.org/package/q)</li>
<li>RSVP (https://npmjs.org/package/rsvp)</li>
<li>Vow (https://npmjs.org/package/vow)</li>
<li>When.js (https://npmjs.org/package/when)</li>
<li>ES6 Promises</li>
</ul>
<p>这些库的区别在于在 Promises/A+ 标准之外的功能上。Promises/A+ 实际上只规范了 <code>then</code> 函数的行为以及 Promises 对象从 pending 状态到 settled 状态的过程。对其他功能并没有规定，比如怎么样创建一个 Promises 对象，即构造函数的函数签名是没有规定的。</p>
<p>关于 ES6 Promises 可以参阅 <a href="https://github.com/DrkSephy/es6-cheatsheet#promises">ES6-cheatsheet</a>。</p>
<h2 id="20160705">20160705</h2>
<h3 id="_3">选股辅助系统</h3>
<p>做一个产品，采集所有股票的历史数据，可以对选股进行辅助分析。用户输入一个股票后，给出买入或卖出的建议。以及股票适合长线还是短线的策略建议。</p>
<ul>
<li>股价全部历史走势图</li>
<li>股价在其历史股价的水平：当前价格与历史最高价的百分比</li>
<li>股价以月为周期的波动情况：波动幅度越大，投机价值越大</li>
<li>股价以年为周期的波动情况</li>
<li>每个季度净利润走势图</li>
<li>每个季度净利润排名走势图</li>
<li>每个季度营收数据走势图</li>
<li>每个季度营收数据排名走势图</li>
<li>每个季度每股收益走势图</li>
<li>每个季度每股收益排名走势图</li>
<li>每个季度每股营收走势图</li>
<li>每个季度每股营收排名走势图</li>
<li>历史分红配股情况：分列出每一年的分红配股情况</li>
<li>历史分红配股情况在所有股票中的排名：需要有个算法，算出每支股票分红配股分数</li>
<li>股价与 深证指数/上证指数 的吻合情况及其排名 （排名：需要算出每支股票与上证指数/深证指数的相关系数）</li>
</ul>
<h2 id="20160706">20160706</h2>
<p>Node.js Design Patterns: Chapeter 2 Asynchronous Control Flow Patterns</p>
<h3 id="promises_1">Promises</h3>
<h4 id="promisifying-a-nodejs-style-function">Promisifying a Node.js style function</h4>
<p>Node.js 库里只有少数几个原生支持 Promises ，我们可以通过转换，把 Node.js 类型的 CPS 回调函数改装成 Promises 样式的函数。</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">var</span> Promise <span style="color: #666666">=</span> require(<span style="color: #BB4444">&#39;bluebird&#39;</span>);

module.exports.promisify <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">function</span> (callbackBasedApi) {
    <span style="color: #AA22FF; font-weight: bold">return</span> <span style="color: #AA22FF; font-weight: bold">function</span> promisified() {
        <span style="color: #008800; font-style: italic">// copy array: copy arguments of function promisified()</span>
        <span style="color: #AA22FF; font-weight: bold">var</span> args <span style="color: #666666">=</span> [].slice.call(arguments);
        <span style="color: #AA22FF; font-weight: bold">return</span> <span style="color: #AA22FF; font-weight: bold">new</span> Promise(<span style="color: #AA22FF; font-weight: bold">function</span> (resolve, reject) {
            args.push(<span style="color: #AA22FF; font-weight: bold">function</span> (err, result) {
                <span style="color: #AA22FF; font-weight: bold">if</span> (err) {
                    <span style="color: #AA22FF; font-weight: bold">return</span> reject(err);
                }
                <span style="color: #AA22FF; font-weight: bold">if</span> (arguments.length <span style="color: #666666">&lt;=</span> <span style="color: #666666">2</span>) {
                    resolve(result);
                } <span style="color: #AA22FF; font-weight: bold">else</span> {
                    resolve([].slice.call(arguments, <span style="color: #666666">1</span>));
                }
            });
            callbackBasedApi.apply(<span style="color: #AA22FF; font-weight: bold">null</span>, args);
        });
    }
};
</pre></div>


<p>大多数 Promises 实现都提供了把传统的 CPS 回调的 API 转换为 Promises 样式的工具函数，比如 Q 的 <code>Q.denodeify()</code>, <code>Q.nbind()</code>，bluebird 的 <code>Promises.promisify()</code> 等。</p>
<h4 id="sequential-execution">Sequential execution</h4>
<p>Promises 对己知函数的顺序执行的模式代码如下：</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">function</span> promisesFunc() {
    <span style="color: #AA22FF; font-weight: bold">return</span> func1(params1)
        .then(<span style="color: #666666">=&gt;</span> (result1) {
            <span style="color: #AA22FF; font-weight: bold">return</span> func2(result1[<span style="color: #666666">0</span>]);
        })
        .then(<span style="color: #666666">=&gt;</span> (result2) {
            <span style="color: #AA22FF; font-weight: bold">return</span> func3(result2);
        })
        .then(<span style="color: #666666">=&gt;</span> (result3)) {
            <span style="color: #AA22FF; font-weight: bold">return</span> func4(result3);
        };
}
</pre></div>


<p>对未知列表进行迭代顺序执行时，其模式代码如下：</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">var</span> tasks <span style="color: #666666">=</span> [...];
<span style="color: #AA22FF; font-weight: bold">var</span> promise <span style="color: #666666">=</span> Promise.resolve();    <span style="color: #008800; font-style: italic">// create a empty Promise Object which resolved as &#39;undefined&#39;</span>
tasks.forEach(<span style="color: #AA22FF; font-weight: bold">function</span> (task) {     <span style="color: #008800; font-style: italic">// chain each task with Promises Object</span>
    promise <span style="color: #666666">=</span> promise.then(<span style="color: #AA22FF; font-weight: bold">function</span> () {
        <span style="color: #AA22FF; font-weight: bold">return</span> task();
    });
});
</pre></div>


<h4 id="parallel-execution_1">Parallel execution</h4>
<p>使用 Promises 也可轻松执行并行任务：</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">function</span> spiderLinks(currentUrl, body, nesting) {
    <span style="color: #AA22FF; font-weight: bold">if</span> (nesting <span style="color: #666666">===</span> <span style="color: #666666">0</span>) {
        <span style="color: #AA22FF; font-weight: bold">return</span> Promise.resolve();
    }
    <span style="color: #AA22FF; font-weight: bold">var</span> links <span style="color: #666666">=</span> utilities.getPageLinks(currentUrl, body);
    <span style="color: #AA22FF; font-weight: bold">var</span> promises <span style="color: #666666">=</span> links.map(<span style="color: #AA22FF; font-weight: bold">function</span> (link) {
        <span style="color: #AA22FF; font-weight: bold">return</span> spider(link, nesting <span style="color: #666666">-</span> <span style="color: #666666">1</span>);
    });
    <span style="color: #AA22FF; font-weight: bold">return</span> Promise.all(promises);
}
</pre></div>


<h4 id="limited-parallel-execution">Limited parallel execution</h4>
<p>ES6 Promises 并没有提供原生的机制来实现并行任务的控制。一个办法是使用 Javascript 原生方法来实现并行执行数量限制，比如<a href="#globally_limiting_the_concurrency">使用 <code>TaskQueue</code> 来实现</a>。</p>
	<hr/>
	<h6>Post by <a href="../author/joey-huang.html">Joey Huang</a> under <a href="../category/notes.html">notes</a> on 2015-04-13(Monday) 00:19.</h6>
</article>

<hr/>
<div class="row">
	<div class="small-12 columns">
		<h3>Comments</h3>
		<div id="disqus_thread"></div>
		<script type="text/javascript">
			var disqus_shortname = 'kamidox';
			(function() {
				var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
				dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
				(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
			})();
		</script>
		<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
		<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
	</div>
</div>
						</div>
						<!-- End Main Content -->
						<!-- Sidebar -->
						<aside class="medium-3 hide-for-small-only columns">
							<div class="panel">
								<h5>Places</h5>
								<ul class="side-nav">
										<li><a href="http://blog.kamidox.com/feeds/rss.xml" rel="alternate">RSS Feed</a></li>

								</ul>
							</div>


							<div class="panel">
								<h5>Categories</h5>
								<ul class="side-nav">
										<li><a href="../category/android.html">android</a></li>
										<li><a href="../category/essay.html">essay</a></li>
										<li><a href="../category/flask.html">flask</a></li>
										<li><a href="../category/ml.html">ml</a></li>
										<li><a href="../category/nlp.html">nlp</a></li>
										<li><a href="../category/python.html">python</a></li>
										<li><a href="../category/tools.html">tools</a></li>
										<li><a href="../category/werkzeug.html">werkzeug</a></li>
								</ul>
							</div>

							<div class="panel">
								<h5>Tags</h5>
								<ul class="tag-cloud">
										<li class="tag-1"><a href="../tag/thought.html">thought</a></li>
										<li class="tag-3"><a href="../tag/pelican.html">pelican</a></li>
										<li class="tag-4"><a href="../tag/contacts.html">contacts</a></li>
										<li class="tag-4"><a href="../tag/nlp.html">nlp</a></li>
										<li class="tag-4"><a href="../tag/contacts-provider.html">contacts provider</a></li>
										<li class="tag-4"><a href="../tag/github.html">github</a></li>
										<li class="tag-2"><a href="../tag/android.html">android</a></li>
										<li class="tag-4"><a href="../tag/wekzeug.html">wekzeug</a></li>
										<li class="tag-4"><a href="../tag/decorator.html">decorator</a></li>
										<li class="tag-2"><a href="../tag/tools.html">tools</a></li>
										<li class="tag-4"><a href="../tag/ebook.html">ebook</a></li>
										<li class="tag-4"><a href="../tag/uml.html">uml</a></li>
										<li class="tag-4"><a href="../tag/miui.html">miui</a></li>
										<li class="tag-2"><a href="../tag/markdown.html">markdown</a></li>
										<li class="tag-2"><a href="../tag/flask.html">flask</a></li>
										<li class="tag-4"><a href="../tag/patchrom.html">patchrom</a></li>
										<li class="tag-4"><a href="../tag/socketserver.html">SocketServer</a></li>
										<li class="tag-1"><a href="../tag/python.html">python</a></li>
										<li class="tag-1"><a href="../tag/machine-learning.html">machine-learning</a></li>
										<li class="tag-3"><a href="../tag/sublime.html">sublime</a></li>
								</ul>
							</div>

							<div class="panel">
								<h5>Monthly Archives</h5>
								<ul class="side-nav">
											<li><a href="/posts/2016/03/index.html">March 2016 (2)</a></li>
											<li><a href="/posts/2016/02/index.html">February 2016 (2)</a></li>
											<li><a href="/posts/2016/01/index.html">January 2016 (2)</a></li>
											<li><a href="/posts/2015/12/index.html">December 2015 (10)</a></li>
											<li><a href="/posts/2015/11/index.html">November 2015 (6)</a></li>
											<li><a href="/posts/2015/10/index.html">October 2015 (2)</a></li>
											<li><a href="/posts/2015/09/index.html">September 2015 (7)</a></li>
											<li><a href="/posts/2015/08/index.html">August 2015 (1)</a></li>
											<li><a href="/posts/2015/07/index.html">July 2015 (1)</a></li>
											<li><a href="/posts/2015/05/index.html">May 2015 (1)</a></li>
											<li><a href="/posts/2015/04/index.html">April 2015 (1)</a></li>
											<li><a href="/posts/2015/03/index.html">March 2015 (3)</a></li>
											<li><a href="/posts/2015/02/index.html">February 2015 (2)</a></li>
											<li><a href="/posts/2015/01/index.html">January 2015 (2)</a></li>
											<li><a href="/posts/2014/12/index.html">December 2014 (3)</a></li>
											<li><a href="/posts/2014/11/index.html">November 2014 (4)</a></li>
											<li><a href="/posts/2014/10/index.html">October 2014 (6)</a></li>
											<li><a href="/posts/2014/09/index.html">September 2014 (1)</a></li>
											<li><a href="/posts/2014/07/index.html">July 2014 (1)</a></li>
								</ul>
							</div>

						</aside>
						<!-- End Sidebar -->
					</div>

					<!-- Footer -->
					<footer class="row">
						<div class="medium-9 small-12">
							<hr/>
							<p class="text-center">Powered by <a href="http://getpelican.com">Pelican</a> and <a href="http://foundation.zurb.com/">Zurb Foundation</a>. Theme by <a href="http://hamaluik.com">Kenton Hamaluik</a>.
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253471695'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/z_stat.php%3Fid%3D1253471695%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
							</p>
						</div>
					</footer>
					<!-- End Footer -->
				</section>
				<a class="exit-off-canvas"></a>
			</div><!--off-canvas inner-->
		</div><!--off-canvas wrap-->

		<script src="../theme/js/jquery.js"></script>
		<script src="../theme/js/foundation.min.js"></script>
		<script>
			$(document).foundation();
		</script>
	</body>
</html>